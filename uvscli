#! /usr/bin/env python


import os
import sys
import argparse
import getpass

from libuvs import log
from libuvs import uvsmanager
from libuvs import systemdefaults as sdef
from libuvs import _version
from libuvs.uvs_errors import *


_REPO_PASS_PROMPT = ">> Passphrase: "


def _init_new_repo():
    """ Initialize a new repository right here in cwd. """

    cwd = os.getcwd()

    log.cli("_init_new_repo() called, repo root: " + cwd )

    shadow_root_path = os.path.join(cwd, sdef._SHADOW_FOLDER_NAME)
    shadow_db_file_path = os.path.join(shadow_root_path, sdef._SHADOW_DB_FILE_NAME)

    if os.path.isfile(shadow_db_file_path):
        print "This directory (" + cwd + ") appears to be a uvs repository already."
        print "Cancelling init to keep this repository."
        print "If you really want to re-init an empty repository here, delete uvs internal folders first."
        print "These should be called: " + sdef._SHADOW_FOLDER_NAME + ", " + sdef._CACHE_FOLDER_NAME
        sys.exit(1)


    # now ask the user for the passphrase
    user_pass = getpass.getpass(prompt=_REPO_PASS_PROMPT)


    uvsmanager.init_new_uvs_repo_overwrite(repo_pass=user_pass, repo_root_path=cwd)


def _commit(commit_msg):
    """ make a new snapshot of the repository. """

    assert None != commit_msg


    # getcwd has issues with cifs mounted shares and also on ubuntu if a folder is deleted then recreated
    # a shell at that folder can get the expected output from running pwd but python os.getcwd() fails with
    # oserror file does not exist. it might be better to use subprocess pwd instead of cwd at least on unix.
    cwd = os.getcwd()

    log.cli("commit called. repo root: " + cwd)

    # if this is a uvs repo uvs db files are here.

    shadow_root_path = os.path.join(cwd, sdef._SHADOW_FOLDER_NAME)
    shadow_db_file_path = os.path.join(shadow_root_path, sdef._SHADOW_DB_FILE_NAME)

    if (not os.path.isdir(shadow_root_path)) or (not os.path.isfile(shadow_db_file_path)):
        print "current working directory does not appear to be a uvs repository."
        sys.exit(1)

    # now ask the user for the passphrase
    user_pass = getpass.getpass(prompt=_REPO_PASS_PROMPT)

    uvsmgr = None

    try:
        uvsmgr = uvsmanager.UVSManager(repo_pass=user_pass , repo_root_path=cwd)
    except UVSErrorTamperDetected as e:
        print e.message
        sys.exit(1)


    snapid = uvsmgr.take_snapshot(snapshot_msg=commit_msg, author_name="sample_name", author_email="sample_email")

    print "commit (snapshot) successfully created. commit id (snapid) is: " + str(snapid)

def _log_commits():
    """ Show a list of all commits in this repo. """


    # getcwd has issues with cifs mounted shares and also on ubuntu if a folder is deleted then recreated
    # a shell at that folder can get the expected output from running pwd but python os.getcwd() fails with
    # oserror file does not exist. it might be better to use subprocess pwd instead of cwd at least on unix.
    cwd = os.getcwd()

    log.cli("_log_commits called. repo root: " + cwd)

    # if this is a uvs repo uvs db files are here.

    shadow_root_path = os.path.join(cwd, sdef._SHADOW_FOLDER_NAME)
    shadow_db_file_path = os.path.join(shadow_root_path, sdef._SHADOW_DB_FILE_NAME)

    if (not os.path.isdir(shadow_root_path)) or (not os.path.isfile(shadow_db_file_path)):
        print "current working directory does not appear to be a uvs repository."
        sys.exit(1)


    # now ask the user for the passphrase
    user_pass = getpass.getpass(prompt=_REPO_PASS_PROMPT)

    uvsmgr = None

    try:
        uvsmgr = uvsmanager.UVSManager(repo_pass=user_pass , repo_root_path=cwd)
    except UVSErrorTamperDetected as e:
        print e.message
        sys.exit(1)

    # TODO handle the case where there might be 700k commits in the repo (show them 100 at a time or something)
    # right just print everything.


    # i am expecting a list of tuples like this;
    # <snapid, commit msg, author name, author email>
    all_snapshots = uvsmgr.list_all_snapshots()


    print "uvs log: found these snapshots:"
    for snapid, msg, name, email in all_snapshots:
        print "commit id: " + str(snapid)
        print "author name: " + str(name) + " email: " + str(email) + " commit msg: " + str(msg) + "\n\n"





def _parse_cmdline():
    """ Given command line arguments to the program are in the arguments list, parse and process them. """


    desc_msg = 'UVSource - End to End Encrypted Distributed Version Control System -- ver: ' + _version.get_version()

    parser = argparse.ArgumentParser(description=desc_msg)

    parser.add_argument("subcmd1", help="what should uvs do", choices=['init', 'log', 'commit', 'branch', 'merge'])
    parser.add_argument("-m", "--message", help="commit message")
    args = parser.parse_args()

    # print type(args) returns  <class 'argparse.Namespace'>
    #log.cliv("argparse args: " + str(args))

    if 'init' == args.subcmd1:
        log.cliv(">>>> init sub command called.")
        _init_new_repo()

    elif 'log' == args.subcmd1:
        log.cliv(">>>> log sub command called.")
        _log_commits()

    elif 'commit' == args.subcmd1:
        log.cliv(">>>> commit sub command called.")

        msg = args.message
        if None == msg:
            print "Commit message is required."
            sys.exit(2)

        _commit(commit_msg=msg)

    elif 'branch' == args.subcmd1:
        print "Not Yet Implemented"

    elif 'merge' == args.subcmd1:
        print "Not Yet Implemented"







if "__main__" == __name__:
    _parse_cmdline()