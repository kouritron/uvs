#! /usr/bin/env python


import os
import sys
import argparse
import getpass

from libuvs import log
from libuvs import uvsmanager
from libuvs import systemdefaults as sdef
from libuvs import version
from libuvs.uvs_errors import *


_REPO_PASS_PROMPT = ">> Passphrase: "


def _init_new_repo():
    """ Initialize a new repository right here in cwd. """

    cwd = os.getcwd()

    log.cli("_init_new_repo() called, repo root: " + cwd)

    shadow_root_path = os.path.join(cwd, sdef.SHADOW_FOLDER_NAME)
    shadow_db_file_path = os.path.join(shadow_root_path, sdef.SHADOW_DB_FILE_NAME)

    if os.path.isfile(shadow_db_file_path):
        print "This directory (" + cwd + ") appears to be a uvs repository already."
        print "Cancelling init to keep this repository."
        print "If you really want to re-init an empty repository here, delete uvs internal folders first."
        print "These should be called: " + sdef.SHADOW_FOLDER_NAME + ", " + sdef.TEMP_DIR_NAME
        sys.exit(1)


    # now ask the user for the passphrase
    user_pass = getpass.getpass(prompt=_REPO_PASS_PROMPT)


    uvsmanager.init_new_uvs_repo_overwrite(repo_pass=user_pass, repo_root_path=cwd)


def _checkout(cid):
    """ checkout the snapshot with the given commit id (snapshot id) """

    assert cid is not None

    # getcwd has issues with cifs mounted shares and also on ubuntu if a folder is deleted then recreated
    # a shell at that folder can get the expected output from running pwd but python os.getcwd() fails with
    # oserror file does not exist. it might be better to use subprocess pwd instead of cwd at least on unix.
    cwd = os.getcwd()

    log.cli("_checkout called. repo root: " + cwd)

    # if this is a uvs repo uvs db files are here.
    shadow_root_path = os.path.join(cwd, sdef.SHADOW_FOLDER_NAME)
    shadow_db_file_path = os.path.join(shadow_root_path, sdef.SHADOW_DB_FILE_NAME)

    if (not os.path.isdir(shadow_root_path)) or (not os.path.isfile(shadow_db_file_path)):
        print "current working directory does not appear to be a uvs repository."
        sys.exit(1)


    # now ask the user for the passphrase
    user_pass = getpass.getpass(prompt=_REPO_PASS_PROMPT)

    uvsmgr = None

    try:
        uvsmgr = uvsmanager.UVSManager(repo_pass=user_pass, repo_root_path=cwd)
    except UVSErrorTamperDetected as e:
        print e.message
        sys.exit(1)

    try:
        uvsmgr.checkout_snapshot(snapid=cid, clear_dest=True)
    except UVSError as e:
        print e.message
        sys.exit(1)




def _commit(commit_msg):
    """ make a new snapshot of the repository. """

    assert commit_msg is not None


    # getcwd has issues with cifs mounted shares and also on ubuntu if a folder is deleted then recreated
    # a shell at that folder can get the expected output from running pwd but python os.getcwd() fails with
    # oserror file does not exist. it might be better to use subprocess pwd instead of cwd at least on unix.
    cwd = os.getcwd()

    log.cli("commit called. repo root: " + cwd)

    # if this is a uvs repo uvs db files are here.

    shadow_root_path = os.path.join(cwd, sdef.SHADOW_FOLDER_NAME)
    shadow_db_file_path = os.path.join(shadow_root_path, sdef.SHADOW_DB_FILE_NAME)

    if (not os.path.isdir(shadow_root_path)) or (not os.path.isfile(shadow_db_file_path)):
        print "current working directory does not appear to be a uvs repository."
        sys.exit(1)

    # now ask the user for the passphrase
    user_pass = getpass.getpass(prompt=_REPO_PASS_PROMPT)

    uvsmgr = None

    try:
        uvsmgr = uvsmanager.UVSManager(repo_pass=user_pass , repo_root_path=cwd)
    except UVSErrorTamperDetected as e:
        print e.message
        sys.exit(1)

    # TODO
    # check if working dir is clean



    snapid = uvsmgr.take_snapshot(snapshot_msg=commit_msg, author_name="n/a", author_email="n/a")

    print "commit (snapshot) successfully created. commit id (snapid) is: " + str(snapid)

def _log_commits():
    """ Show a list of all commits in this repo. """


    # getcwd has issues with cifs mounted shares and also on ubuntu if a folder is deleted then recreated
    # a shell at that folder can get the expected output from running pwd but python os.getcwd() fails with
    # oserror file does not exist. it might be better to use subprocess pwd instead of cwd at least on unix.
    cwd = os.getcwd()

    log.cli("_log_commits called. repo root: " + cwd)

    # if this is a uvs repo uvs db files are here.

    shadow_root_path = os.path.join(cwd, sdef.SHADOW_FOLDER_NAME)
    shadow_db_file_path = os.path.join(shadow_root_path, sdef.SHADOW_DB_FILE_NAME)

    if (not os.path.isdir(shadow_root_path)) or (not os.path.isfile(shadow_db_file_path)):
        print "current working directory does not appear to be a uvs repository."
        sys.exit(1)


    # now ask the user for the passphrase
    user_pass = getpass.getpass(prompt=_REPO_PASS_PROMPT)

    uvsmgr = None

    try:
        uvsmgr = uvsmanager.UVSManager(repo_pass=user_pass , repo_root_path=cwd)
    except UVSErrorTamperDetected as e:
        print e.message
        sys.exit(1)

    # TODO handle the case where there might be 700k commits in the repo (show them 100 at a time or something)
    # right now we just print everything.

    # i am expecting a list of tuples like this;
    # <snapid, commit msg, author name, author email>
    all_snapshots = uvsmgr.list_all_snapshots()


    print "uvs log: found these snapshots:"
    for snapid, msg, name, email in all_snapshots:
        print "commit id: " + str(snapid)
        print "author name: " + str(name) + " email: " + str(email) + " commit msg: " + str(msg) + "\n\n"



def _show_status():
    """ Print the status of the repository.
    this includes head, head state, and whether working directory is clean or not.
    """

    # getcwd has issues with cifs mounted shares and also on ubuntu if a folder is deleted then recreated
    # a shell at that folder can get the expected output from running pwd but python os.getcwd() fails with
    # oserror file does not exist. it might be better to use subprocess pwd instead of cwd at least on unix.
    cwd = os.getcwd()

    log.cli("_show_status called. repo root: " + cwd)

    # if this is a uvs repo uvs db files are here.

    shadow_root_path = os.path.join(cwd, sdef.SHADOW_FOLDER_NAME)
    shadow_db_file_path = os.path.join(shadow_root_path, sdef.SHADOW_DB_FILE_NAME)

    if (not os.path.isdir(shadow_root_path)) or (not os.path.isfile(shadow_db_file_path)):
        print "current working directory does not appear to be a uvs repository."
        sys.exit(1)

    # now ask the user for the passphrase
    user_pass = getpass.getpass(prompt=_REPO_PASS_PROMPT)

    uvsmgr = None

    try:
        uvsmgr = uvsmanager.UVSManager(repo_pass=user_pass, repo_root_path=cwd)
    except UVSErrorTamperDetected as e:
        print e.message
        sys.exit(1)

    repo_status = uvsmgr.get_status()

    # repo_status["working_dir_clean"]: True/False    # true if there are no un-committed changes.
    # repo_status["head"]: commit id                  # (snapid) of the repository head, or None if repo empty.
    # repo_status["detached_head"]: True/False        # detached or attached to a branch
    #
    # if  "detached_head" is False: this key, value also present:
    # repo_status["current_branch"]: "branch_name"

    if repo_status['working_dir_clean']:
        print "working directory is clean."
    else:
        print "working directory has un-committed changes."


    if repo_status['head'] is None:
        print "uvs repository appears to be emtpy."
    else:
        if repo_status['detached_head']:
            print "head is in detached state."
            print "head is at commit: " + str(repo_status["head"])
        else:
            print "head is attached to current branch: " + str(repo_status['current_branch'])
            print "head is at commit: " + str(repo_status["head"])


def _branch(new_branch_name):
    """ Create a new branch with the supplied name.
    The new branch will point to whatever head points right now.
    """

    assert new_branch_name is not None

    # getcwd has issues with cifs mounted shares and also on ubuntu if a folder is deleted then recreated
    # a shell at that folder can get the expected output from running pwd but python os.getcwd() fails with
    # oserror file does not exist. it might be better to use subprocess pwd instead of cwd at least on unix.
    cwd = os.getcwd()

    log.cli("creating new branch: " + str(new_branch_name) + "\nrepo root: " + cwd)

    # if this is a uvs repo uvs db files are here.

    shadow_root_path = os.path.join(cwd, sdef.SHADOW_FOLDER_NAME)
    shadow_db_file_path = os.path.join(shadow_root_path, sdef.SHADOW_DB_FILE_NAME)

    if (not os.path.isdir(shadow_root_path)) or (not os.path.isfile(shadow_db_file_path)):
        print "current working directory does not appear to be a uvs repository."
        sys.exit(1)

    # now ask the user for the passphrase
    user_pass = getpass.getpass(prompt=_REPO_PASS_PROMPT)

    uvsmgr = None

    try:
        uvsmgr = uvsmanager.UVSManager(repo_pass=user_pass, repo_root_path=cwd)
    except UVSErrorTamperDetected as e:
        print e.message
        sys.exit(1)

    #
    uvsmgr.create_new_branch(new_branch_name=new_branch_name, set_current_branch=False)



def _parse_cmdline():
    """ Given command line arguments to the program are in the arguments list, parse and process them. """


    desc_msg = 'UVSource - End to End Encrypted Distributed Version Control System -- ver: ' + version.get_version()

    parser = argparse.ArgumentParser(description=desc_msg)

    parser.add_argument("subcmd1", help="what should uvs do",
                        choices=['init', 'status', 'log', 'commit', 'checkout', 'branch', 'merge'])

    parser.add_argument("-m", "--message", help="commit message")
    parser.add_argument("-c", "--cid", help="commit id")
    parser.add_argument("-n", "--name", help="branch name.")
    args = parser.parse_args()

    # print type(args) returns  <class 'argparse.Namespace'>
    #log.cliv("argparse args: " + str(args))

    if 'init' == args.subcmd1:
        log.cliv(">>>> init sub command called.")
        _init_new_repo()

    elif 'status' == args.subcmd1:
        log.cliv(">>>> status sub command called.")
        _show_status()

    elif 'log' == args.subcmd1:
        log.cliv(">>>> log sub command called.")
        _log_commits()

    elif 'commit' == args.subcmd1:
        log.cliv(">>>> commit sub command called.")

        msg = args.message
        if None == msg:
            print "Commit message is required."
            sys.exit(2)

        _commit(commit_msg=msg)

    elif 'checkout' == args.subcmd1:
        log.cliv(">>>> checkout sub command called.")

        cid = args.cid
        if None == cid:
            print "commit id (-c or --cid) is required."
            sys.exit(2)

        _checkout(cid=cid)

    elif 'branch' == args.subcmd1:
        log.cliv(">>>> branch sub command called.")

        new_branch_name = args.name
        if None == new_branch_name:
            print "Error: No branch name supplied. please supply a branch name (-n or --name)"
            sys.exit(2)

        _branch(new_branch_name=new_branch_name)

    elif 'merge' == args.subcmd1:
        print "Not Yet Implemented"







if "__main__" == __name__:
    _parse_cmdline()