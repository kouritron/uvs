#! /usr/bin/env python


import os
import sys
import argparse
import getpass
import json

from libuvs import log
from libuvs import uvsmanager
from libuvs import systemdefaults as sdef
from libuvs import version
from libuvs.uvs_errors import *


_REPO_PASS_PROMPT = ">> Passphrase: "


def _init_new_repo():
    """ Initialize a new repository right here in cwd. """

    cwd = os.getcwd()

    log.cli("_init_new_repo() called, repo root: " + cwd)

    shadow_root_path = os.path.join(cwd, sdef.SHADOW_FOLDER_NAME)
    shadow_db_file_path = os.path.join(shadow_root_path, sdef.SHADOW_DB_FILE_NAME)

    if os.path.isfile(shadow_db_file_path):
        print "This directory (" + cwd + ") appears to be a uvs repository already."
        print "Cancelling init to keep this repository."
        print "If you really want to re-init an empty repository here, delete uvs internal folders first."
        print "These should be called: " + sdef.SHADOW_FOLDER_NAME + ", " + sdef.TEMP_DIR_NAME
        sys.exit(1)


    # now ask the user for the passphrase
    user_pass = getpass.getpass(prompt=_REPO_PASS_PROMPT)


    uvsmanager.init_new_uvs_repo_overwrite(repo_pass=user_pass, repo_root_path=cwd)


def _checkout(commit_ref):
    """ checkout the snapshot with the given commit reference (which can be commit id or branch name) """

    assert commit_ref is not None

    # getcwd has issues with cifs mounted shares and also on ubuntu if a folder is deleted then recreated
    # a shell at that folder can get the expected output from running pwd but python os.getcwd() fails with
    # oserror file does not exist. it might be better to use subprocess pwd instead of cwd at least on unix.
    cwd = os.getcwd()

    log.cli("_checkout called. repo root: " + cwd)

    # if this is a uvs repo uvs db files are here.
    shadow_root_path = os.path.join(cwd, sdef.SHADOW_FOLDER_NAME)
    shadow_db_file_path = os.path.join(shadow_root_path, sdef.SHADOW_DB_FILE_NAME)

    if (not os.path.isdir(shadow_root_path)) or (not os.path.isfile(shadow_db_file_path)):
        print "current working directory does not appear to be a uvs repository."
        sys.exit(1)


    # now ask the user for the passphrase
    user_pass = getpass.getpass(prompt=_REPO_PASS_PROMPT)

    uvsmgr = None

    try:
        uvsmgr = uvsmanager.UVSManager(repo_pass=user_pass, repo_root_path=cwd)
    except UVSErrorTamperDetected as e:
        print e.message
        sys.exit(1)

    result = None
    try:
        result = uvsmgr.checkout_reference_at_repo_root(snapshot_ref=commit_ref, clear_dest=True)
    except UVSError as e:
        print e.message
        sys.exit(1)

    if result and result['op_failed']:
        print "operation failed"
        if result.has_key('op_failed_desc'):
            print "cause: " + str(result['op_failed_desc'])
    else:
        print "successfully checked out: " + str(commit_ref)
        if result.has_key("detached_head") and result['detached_head']:
            print "head is in detached state."

        if result.has_key("head_attached_to") :
            print "head is attached to: " + str(result['head_attached_to'])



def _commit(commit_msg):
    """ make a new snapshot of the repository. """

    assert commit_msg is not None


    # getcwd has issues with cifs mounted shares and also on ubuntu if a folder is deleted then recreated
    # a shell at that folder can get the expected output from running pwd but python os.getcwd() fails with
    # oserror file does not exist. it might be better to use subprocess pwd instead of cwd at least on unix.
    cwd = os.getcwd()

    log.cli("commit called. repo root: " + cwd)

    # if this is a uvs repo uvs db files are here.

    shadow_root_path = os.path.join(cwd, sdef.SHADOW_FOLDER_NAME)
    shadow_db_file_path = os.path.join(shadow_root_path, sdef.SHADOW_DB_FILE_NAME)

    if (not os.path.isdir(shadow_root_path)) or (not os.path.isfile(shadow_db_file_path)):
        print "current working directory does not appear to be a uvs repository."
        sys.exit(1)

    # now ask the user for the passphrase
    user_pass = getpass.getpass(prompt=_REPO_PASS_PROMPT)

    uvsmgr = None

    try:
        uvsmgr = uvsmanager.UVSManager(repo_pass=user_pass , repo_root_path=cwd)
    except UVSErrorTamperDetected as e:
        print e.message
        sys.exit(1)

    # TODO
    # check if working dir is clean



    snapid = uvsmgr.take_snapshot(snapshot_msg=commit_msg, author_name="n/a", author_email="n/a")

    print "commit (snapshot) successfully created. commit id (snapid) is: \n" + str(snapid)

def _log_all_commits():
    """ Show a list of all commits in this repo. """


    # getcwd has issues with cifs mounted shares and also on ubuntu if a folder is deleted then recreated
    # a shell at that folder can get the expected output from running pwd but python os.getcwd() fails with
    # oserror file does not exist. it might be better to use subprocess pwd instead of cwd at least on unix.
    cwd = os.getcwd()

    log.cli("_log_commits called. repo root: " + cwd)

    # if this is a uvs repo uvs db files are here.

    shadow_root_path = os.path.join(cwd, sdef.SHADOW_FOLDER_NAME)
    shadow_db_file_path = os.path.join(shadow_root_path, sdef.SHADOW_DB_FILE_NAME)

    if (not os.path.isdir(shadow_root_path)) or (not os.path.isfile(shadow_db_file_path)):
        print "current working directory does not appear to be a uvs repository."
        sys.exit(1)


    # now ask the user for the passphrase
    user_pass = getpass.getpass(prompt=_REPO_PASS_PROMPT)

    uvsmgr = None

    try:
        uvsmgr = uvsmanager.UVSManager(repo_pass=user_pass , repo_root_path=cwd)
    except UVSErrorTamperDetected as e:
        print e.message
        sys.exit(1)

    # TODO handle the case where there might be 700k commits in the repo (show them 100 at a time or something)
    # right now we just print everything.

    # i am expecting a list of tuples like this;
    # <snapid, commit msg, author name, author email>
    all_snapshots = uvsmgr.list_all_snapshots()


    print "uvs log: found these snapshots:"
    for snapid, msg, name, email in all_snapshots:
        print "commit id: " + str(snapid)
        print "author name: " + str(name) + " email: " + str(email) + " commit msg: " + str(msg) + "\n\n"



def _show_status():
    """ Print the status of the repository.
    this includes head, head state, and whether working directory is clean or not.
    """

    # getcwd has issues with cifs mounted shares and also on ubuntu if a folder is deleted then recreated
    # a shell at that folder can get the expected output from running pwd but python os.getcwd() fails with
    # oserror file does not exist. it might be better to use subprocess pwd instead of cwd at least on unix.
    cwd = os.getcwd()

    log.cli("_show_status called. repo root: " + cwd)

    # if this is a uvs repo uvs db files are here.

    shadow_root_path = os.path.join(cwd, sdef.SHADOW_FOLDER_NAME)
    shadow_db_file_path = os.path.join(shadow_root_path, sdef.SHADOW_DB_FILE_NAME)

    if (not os.path.isdir(shadow_root_path)) or (not os.path.isfile(shadow_db_file_path)):
        print "current working directory does not appear to be a uvs repository."
        sys.exit(1)

    # now ask the user for the passphrase
    user_pass = getpass.getpass(prompt=_REPO_PASS_PROMPT)

    uvsmgr = None

    try:
        uvsmgr = uvsmanager.UVSManager(repo_pass=user_pass, repo_root_path=cwd)
    except UVSErrorTamperDetected as e:
        print e.message
        sys.exit(1)

    repo_status = uvsmgr.get_status()

    # repo_status["working_dir_clean"]: True/False    # true if there are no un-committed changes.
    # repo_status["head"]: commit id                  # (snapid) of the repository head, or None if repo empty.
    # repo_status["detached_head"]: True/False        # detached or attached to a branch
    #
    # if  "detached_head" is False: this key, value also present:
    # repo_status["current_branch"]: "branch_name"

    if repo_status['working_dir_clean']:
        print "working directory is clean."
    else:
        print "working directory has un-committed changes."


    if repo_status['head'] is None:
        print "uvs repository appears to be emtpy."
    else:
        if repo_status['detached_head']:
            print "head is in detached state."
            print "head is at commit: " + str(repo_status["head"])
        else:
            print "head is attached to current branch: " + str(repo_status['current_branch'])
            print "head is at commit: " + str(repo_status["head"])


def _branch(new_branch_name):
    """ Create a new branch with the supplied name.
    The new branch will point to whatever head points right now.
    """

    assert new_branch_name is not None

    # getcwd has issues with cifs mounted shares and also on ubuntu if a folder is deleted then recreated
    # a shell at that folder can get the expected output from running pwd but python os.getcwd() fails with
    # oserror file does not exist. it might be better to use subprocess pwd instead of cwd at least on unix.
    cwd = os.getcwd()

    log.cli("creating new branch: " + str(new_branch_name) + "\nrepo root: " + cwd)

    # if this is a uvs repo uvs db files are here.

    shadow_root_path = os.path.join(cwd, sdef.SHADOW_FOLDER_NAME)
    shadow_db_file_path = os.path.join(shadow_root_path, sdef.SHADOW_DB_FILE_NAME)

    if (not os.path.isdir(shadow_root_path)) or (not os.path.isfile(shadow_db_file_path)):
        print "current working directory does not appear to be a uvs repository."
        sys.exit(1)

    # now ask the user for the passphrase
    user_pass = getpass.getpass(prompt=_REPO_PASS_PROMPT)

    uvsmgr = None

    try:
        uvsmgr = uvsmanager.UVSManager(repo_pass=user_pass, repo_root_path=cwd)
    except UVSErrorTamperDetected as e:
        print e.message
        sys.exit(1)

    #
    result = uvsmgr.create_new_branch(new_branch_name=new_branch_name, set_current_branch=False)

    if result is None:
        print "Create new branch failed with nil return"

    if result['op_failed']:
        print "operation failed"
        if result.has_key('op_failed_desc'):
            print "cause: " + str(result['op_failed_desc'])
    else:
        print 'successfully created branch: ' + str(new_branch_name)


def _show_inverted_dag():
    """ Print the history DAG of this repository with parent pointers inverted to kid pointers. """


    # getcwd has issues with cifs mounted shares and also on ubuntu if a folder is deleted then recreated
    # a shell at that folder can get the expected output from running pwd but python os.getcwd() fails with
    # oserror file does not exist. it might be better to use subprocess pwd instead of cwd at least on unix.
    cwd = os.getcwd()

    log.cli("_show_history_dag() called. repo root: " + cwd)

    # if this is a uvs repo uvs db files are here.
    shadow_root_path = os.path.join(cwd, sdef.SHADOW_FOLDER_NAME)
    shadow_db_file_path = os.path.join(shadow_root_path, sdef.SHADOW_DB_FILE_NAME)

    if (not os.path.isdir(shadow_root_path)) or (not os.path.isfile(shadow_db_file_path)):
        print "current working directory does not appear to be a uvs repository."
        sys.exit(1)

    # now ask the user for the passphrase
    user_pass = getpass.getpass(prompt=_REPO_PASS_PROMPT)

    uvsmgr = None

    try:
        uvsmgr = uvsmanager.UVSManager(repo_pass=user_pass, repo_root_path=cwd)
    except UVSErrorTamperDetected as e:
        print e.message
        sys.exit(1)

    #
    result = uvsmgr.get_inverted_history_dag()

    if result is None:
        print "Computing inverted history dag failed with nil return"

    if result['op_failed']:
        print "operation failed"
        if result.has_key('op_failed_desc'):
            print "cause: " + str(result['op_failed_desc'])
    else:
        # result['dag_root'] is the snapid of repo root.
        # result['dag_adjacencies'] is a dict of <parent snapid, [list of kid snapids] >
        print '>>>>>>>> Here is the inverted DAG (parent to kid):'
        print 'inverted DAG root:' + str(result['dag_root'])
        print 'inverted DAG adjacencies: '

        print json.dumps(result['dag_adjacencies'], indent=4, sort_keys=True)


def _merge(branch_to_merge_from):

    assert branch_to_merge_from is not None

    # getcwd has issues with cifs mounted shares and also on ubuntu if a folder is deleted then recreated
    # a shell at that folder can get the expected output from running pwd but python os.getcwd() fails with
    # oserror file does not exist. it might be better to use subprocess pwd instead of cwd at least on unix.
    cwd = os.getcwd()

    log.cli("_merge() called. branch_to_merge_from: " + str(branch_to_merge_from) + " repo root: " + cwd)

    # if this is a uvs repo uvs db files are here.
    shadow_root_path = os.path.join(cwd, sdef.SHADOW_FOLDER_NAME)
    shadow_db_file_path = os.path.join(shadow_root_path, sdef.SHADOW_DB_FILE_NAME)

    if (not os.path.isdir(shadow_root_path)) or (not os.path.isfile(shadow_db_file_path)):
        print "current working directory does not appear to be a uvs repository."
        sys.exit(1)

    # now ask the user for the passphrase
    user_pass = getpass.getpass(prompt=_REPO_PASS_PROMPT)

    uvsmgr = None

    try:
        uvsmgr = uvsmanager.UVSManager(repo_pass=user_pass, repo_root_path=cwd)
    except UVSErrorTamperDetected as e:
        print e.message
        sys.exit(1)

    #
    result = uvsmgr.merge(branch_to_merge_from=branch_to_merge_from)

    if result is None:
        print "merge failed with nil return"

    if result['op_failed']:
        print "operation failed"
        if result.has_key('op_failed_desc'):
            print "cause: " + str(result['op_failed_desc'])
    elif result['fast_forwarded']:
        print str(branch_to_merge_from) + 'is a direct descendant. fast forwarding current branch.'
        print "merge complete"





def _show_all_refs():
    """ Print all branch names found in the repository.
     TODO: add tags support here as well later when libuvs does. """

    # getcwd has issues with cifs mounted shares and also on ubuntu if a folder is deleted then recreated
    # a shell at that folder can get the expected output from running pwd but python os.getcwd() fails with
    # oserror file does not exist. it might be better to use subprocess pwd instead of cwd at least on unix.
    cwd = os.getcwd()

    log.cli("_show_all_refs() called. repo root: " + cwd)

    # if this is a uvs repo uvs db files are here.

    shadow_root_path = os.path.join(cwd, sdef.SHADOW_FOLDER_NAME)
    shadow_db_file_path = os.path.join(shadow_root_path, sdef.SHADOW_DB_FILE_NAME)

    if (not os.path.isdir(shadow_root_path)) or (not os.path.isfile(shadow_db_file_path)):
        print "current working directory does not appear to be a uvs repository."
        sys.exit(1)

    # now ask the user for the passphrase
    user_pass = getpass.getpass(prompt=_REPO_PASS_PROMPT)

    uvsmgr = None

    try:
        uvsmgr = uvsmanager.UVSManager(repo_pass=user_pass, repo_root_path=cwd)
    except UVSErrorTamperDetected as e:
        print e.message
        sys.exit(1)

    #
    result = uvsmgr.list_all_refs()

    if result is None:
        print "Operation failed with nil return"


    if result['op_failed']:
        print "operation failed"
        if result.has_key('op_failed_desc'):
            print "cause: " + str(result['op_failed_desc'])
    else:

        print 'Here are the references: \n'
        print 'head'.ljust(12) + " : " + str(result['refs']['head'])

        for k, v in result['refs'].items():
            if 'head' != k.lower():
                print str(k).ljust(12) + " : " + str(v)





def _parse_cmdline():
    """ Given command line arguments to the program are in the arguments list, parse and process them. """


    desc_msg = 'UVSource - End to End Encrypted Distributed Version Control System -- ver: ' + version.get_version()

    parser = argparse.ArgumentParser(description=desc_msg)

    parser.add_argument("subcmd1", help="what should uvs do",
                        choices=['init', 'status', 'log-all', 'commit', 'checkout', 'branch', 'merge', 'show-refs',
                                 'show-inv-dag'])

    parser.add_argument("-m", "--message", help="commit message")
    parser.add_argument("-r", "--ref", help="commit reference, either a commit id or branch name")
    parser.add_argument("-n", "--name", help="branch name.")
    args = parser.parse_args()

    # print type(args) returns  <class 'argparse.Namespace'>
    #log.cliv("argparse args: " + str(args))

    if 'init' == args.subcmd1:
        log.cliv(">>>> init sub command called.")
        _init_new_repo()

    elif 'status' == args.subcmd1:
        log.cliv(">>>> status sub command called.")
        _show_status()

    elif 'log-all' == args.subcmd1:
        log.cliv(">>>> log-all sub command called.")
        _log_all_commits()

    elif 'show-refs' == args.subcmd1:
        log.cliv(">>>> show-refs sub command called.")
        _show_all_refs()

    elif 'show-inv-dag' == args.subcmd1:
        log.cliv(">>>> show-inv-dag sub command called.")
        _show_inverted_dag()

    elif 'commit' == args.subcmd1:
        log.cliv(">>>> commit sub command called.")

        msg = args.message
        if None == msg:
            print "Commit message is required."
            sys.exit(2)

        _commit(commit_msg=msg)

    elif 'checkout' == args.subcmd1:
        log.cliv(">>>> checkout sub command called.")

        commit_ref = args.ref
        if None == commit_ref:
            print "commit reference (-r or --ref) is required."
            sys.exit(2)

        _checkout(commit_ref=commit_ref)

    elif 'branch' == args.subcmd1:
        log.cliv(">>>> branch sub command called.")

        new_branch_name = args.name
        if None == new_branch_name:
            print "Error: No branch name supplied. please supply a branch name (-n or --name)"
            sys.exit(2)

        _branch(new_branch_name=new_branch_name)

    elif 'merge' == args.subcmd1:
        log.cliv(">>>> merge sub command called.")

        branch_to_merge_from = args.name
        if None == branch_to_merge_from:
            print "Error: No branch name supplied. please supply a branch name (-n or --name) to merge changes from"
            sys.exit(2)

        _merge(branch_to_merge_from=branch_to_merge_from)







if "__main__" == __name__:
    _parse_cmdline()